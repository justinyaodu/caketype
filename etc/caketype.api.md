## API Report File for "caketype"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const any: TypeGuardCake<any>;

// @public
export function array<B extends Bakeable>(bakeable: B): ArrayCake<Baked<B>>;

// @public (undocumented)
export class ArrayCake<C extends Cake = Cake> extends TupleCake<readonly [], readonly [], C, readonly []> implements ArrayCakeArgs<C> {
    constructor(args: ArrayCakeArgs<C>);
    // (undocumented)
    readonly element: C;
    // (undocumented)
    withName(name: string | null): ArrayCake<C>;
}

// @public (undocumented)
export interface ArrayCakeArgs<C extends Cake> extends CakeArgs {
    // (undocumented)
    element: C;
}

// @public
export type Assert<T extends true> = never;

// @public
export type AssertExtends<T extends U, U> = never;

// @public
export function bake<B extends Bakeable>(bakeable: B): Baked<B>;

// @public
export type Bakeable = Cake | Primitive | ObjectBakeable;

// @public
export type Baked<B extends Bakeable> = B extends Cake ? B : B extends Primitive ? LiteralCake<B> : B extends ObjectBakeable ? ObjectCake<{
    -readonly [K in keyof B]: B[K] extends OptionalTag<infer I extends Bakeable> ? OptionalTag<Baked<I>> : B[K] extends Bakeable ? Baked<B[K]> : never;
}> : never;

// @public
export const bigint: TypeGuardCake<bigint>;

// @public
export const boolean: TypeGuardCake<boolean>;

// Warning: (ae-forgotten-export) The symbol "Untagged" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Cake<in out T = any> extends Untagged implements CakeArgs {
    constructor(args: CakeArgs);
    as(value: unknown): T;
    asShape(value: unknown): T;
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
    check(value: unknown): Result<T, CakeError>;
    checkShape(value: unknown): Result<T, CakeError>;
    // (undocumented)
    abstract dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    abstract dispatchStringify(context: CakeDispatchStringifyContext): string;
    is(value: unknown): value is T;
    isShape(value: unknown): value is T;
    // (undocumented)
    readonly name: string | null;
    // Warning: (ae-forgotten-export) The symbol "CheckOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly options: Partial<CheckOptions>;
    toString(): string;
    // (undocumented)
    abstract withName(name: string | null): Cake<T>;
}

// @public (undocumented)
export interface CakeArgs {
    // (undocumented)
    readonly name?: string | null;
    // (undocumented)
    readonly options?: Partial<CheckOptions>;
}

// @public (undocumented)
export interface CakeDispatchCheckContext {
    // (undocumented)
    readonly getOption: <K extends keyof CheckOptions>(self: Cake, key: K) => CheckOptions[K];
    // (undocumented)
    readonly recurse: (cake: Cake, value: unknown) => CakeError | null;
}

// @public (undocumented)
export interface CakeDispatchStringifyContext {
    // (undocumented)
    readonly recurse: (cake: Cake) => string;
}

// @public
export abstract class CakeError {
    // (undocumented)
    abstract dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    throw(): never;
    toString(): string;
}

// @public (undocumented)
export interface CakeErrorDispatchFormatContext {
    // (undocumented)
    readonly recurse: (error: CakeError) => StringTree;
    // (undocumented)
    readonly stringifyCake: (cake: Cake) => string;
}

// Warning: (ae-internal-missing-underscore) The name "Checker" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Checker {
    constructor(options?: CheckOptions);
    // (undocumented)
    protected readonly cache: Map<Cake, Map<unknown, CakeError | null | undefined>>;
    // (undocumented)
    check<T>(cake: Cake<T>, value: unknown): Result<T, CakeError>;
    // (undocumented)
    protected checkDispatch(cake: Cake, value: unknown): CakeError | null;
    // (undocumented)
    protected checkVisit(cake: Cake, value: unknown): CakeError | null;
    // (undocumented)
    protected readonly context: CakeDispatchCheckContext;
    // (undocumented)
    protected getOption<K extends keyof CheckOptions>(self: Cake, key: K): CheckOptions[K];
    // (undocumented)
    protected readonly options: CheckOptions;
}

// Warning: (ae-internal-missing-underscore) The name "CircularReferenceCakeError" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class CircularReferenceCakeError extends CakeError {
    constructor(cake: Cake, value: unknown);
    // (undocumented)
    readonly cake: Cake;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown;
}

// @public
export interface Class<T = any, A extends unknown[] = any> extends Function {
    // (undocumented)
    new (...args: A): T;
}

// Warning: (ae-forgotten-export) The symbol "DeepMapLike" needs to be exported by the entry point index.d.ts
//
// @public
export function deepDelete<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): boolean;

// Warning: (ae-forgotten-export) The symbol "DeepValue" needs to be exported by the entry point index.d.ts
//
// @public
export function deepDeleteResult<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): Result<DeepValue<M, K>, undefined>;

// @public
export function deepGet<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): DeepValue<M, K> | undefined;

// @public
export function deepGetResult<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): Result<DeepValue<M, K>, undefined>;

// @public
export function deepHas<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): boolean;

// Warning: (ae-forgotten-export) The symbol "DeepMap" needs to be exported by the entry point index.d.ts
//
// @public
export function deepSet<M extends DeepMap<K>, K extends [unknown, ...unknown[]]>(map: M, ...keysAndValue: [...K, DeepValue<M, K>]): void;

// @public
export function deleteResult<K, V>(map: MapLike<K, V>, key: K): Result<V, undefined>;

// @public
export function entries(object: object): [string, unknown][];

// @public
export function entriesIncludingSymbols(object: object): [string | symbol, unknown][];

// @public
export function entriesIncludingSymbolsUnsound<T extends object>(object: T): EntryIncludingSymbols<T>[];

// @public
export function entriesUnsound<T extends object>(object: T): Entry<T>[];

// @public
export type Entry<T extends object> = {
    [K in keyof T & string]: [K, T[K]];
}[keyof T & string];

// @public
export type EntryIncludingSymbols<T extends object> = {
    [K in keyof T & (string | symbol)]: [K, T[K]];
}[keyof T & (string | symbol)];

// @public
export type Equivalent<T, U> = [T] extends [U] ? [U] extends [T] ? true : false : false;

// Warning: (ae-forgotten-export) The symbol "ResultClass" needs to be exported by the entry point index.d.ts
// Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
//
// @public
export class Err<E> extends ResultClass<never, E> {
    // @internal
    constructor(error: E);
    readonly error: E;
    // (undocumented)
    errorOr(_IGNORED: unknown): E;
    readonly ok = false;
    // (undocumented)
    toString(): string;
    // (undocumented)
    valueOr<U>(ifErr: U): U;
}

// @public
export type Extends<T, U> = [T] extends [U] ? true : false;

// @public
export function getOrSet<K, V>(map: MapLike<K, V>, key: K, defaultValue: V): V;

// @public
export function getOrSetComputed<K, V>(map: MapLike<K, V>, key: K, keyToDefaultValue: (key: K) => V): V;

// @public
export function getResult<K, V>(map: MapLike<K, V>, key: K): Result<V, undefined>;

// @public
export type If<T extends boolean, U, V> = T extends true ? U : V;

// @public
export type Infer<C extends Cake> = C extends Cake<infer T> ? T : never;

// @public
export function isPrimitive(value: unknown): value is Primitive;

// @public
export function keys(object: object): string[];

// @public
export function keysIncludingSymbols(object: object): (string | symbol)[];

// @public
export function keysIncludingSymbolsUnsound<T extends object>(object: T): (keyof T & (string | symbol))[];

// @public
export function keysUnsound<T extends object>(object: T): (keyof T & string)[];

// @public (undocumented)
export class LiteralCake<P extends Primitive> extends Cake<P> implements LiteralCakeArgs<P> {
    constructor(args: LiteralCakeArgs<P>);
    // (undocumented)
    dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    dispatchStringify(context: CakeDispatchStringifyContext): string;
    // (undocumented)
    readonly value: P;
    // (undocumented)
    withName(name: string | null): LiteralCake<P>;
}

// @public (undocumented)
export interface LiteralCakeArgs<P extends Primitive> extends CakeArgs {
    // (undocumented)
    value: P;
}

// @public (undocumented)
export class LiteralNotEqualCakeError extends CakeError {
    constructor(cake: LiteralCake<any>, value: unknown);
    // (undocumented)
    readonly cake: LiteralCake<any>;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown;
}

// Warning: (ae-forgotten-export) The symbol "LookupReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function lookup<K extends PropertyKey, T extends [object, ...object[]]>(key: K, ...objects: T): LookupReturn<K, T>;

// @public
export interface MapLike<K, V> {
    delete(key: K): boolean;
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): MapLike<K, V>;
}

// @public
export const MapUtils: {
    readonly deleteResult: typeof deleteResult;
    readonly deepDelete: typeof deepDelete;
    readonly deepDeleteResult: typeof deepDeleteResult;
    readonly deepGet: typeof deepGet;
    readonly deepGetResult: typeof deepGetResult;
    readonly deepHas: typeof deepHas;
    readonly deepSet: typeof deepSet;
    readonly getOrSet: typeof getOrSet;
    readonly getOrSetComputed: typeof getOrSetComputed;
    readonly getResult: typeof getResult;
};

// @public
export function mapValues<T extends object, R>(object: T, mapper: (value: unknown, key: string | symbol, object: T) => R): {
    [K in keyof T & (string | symbol)]: R;
};

// @public
export function mapValuesUnsound<T extends object, R>(object: T, mapper: <K extends keyof T & (string | symbol)>(value: T[K], key: K, object: T) => R): {
    [K in keyof T & (string | symbol)]: R;
};

// @public
export function merge<T extends [object, ...object[]]>(...objects: T): Merged<T>;

// Warning: (ae-forgotten-export) The symbol "MergeTwo" needs to be exported by the entry point index.d.ts
//
// @public
export type Merged<T extends [object, ...object[]]> = T extends [
infer F extends object,
infer S extends object,
...infer R extends object[]
] ? Merged<[MergeTwo<F, S>, ...R]> : T extends [infer F extends object] ? MergeTwo<F, {}> : never;

// @public
export const never: TypeGuardCake<never>;

// @public
export type Not<T extends boolean> = T extends true ? false : true;

// @public (undocumented)
export class NotAnArrayCakeError extends CakeError {
    constructor(cake: Cake, value: unknown);
    // (undocumented)
    readonly cake: Cake;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown;
}

// @public (undocumented)
export class NotAnObjectCakeError extends CakeError {
    constructor(cake: Cake, value: unknown);
    // (undocumented)
    readonly cake: Cake;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown;
}

// @public
export const number: TypeGuardCake<number>;

// @public
export type ObjectBakeable = {
    [key: string | symbol]: Bakeable | OptionalTag<Bakeable>;
};

// Warning: (ae-forgotten-export) The symbol "OnlyRequiredKeys" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "OnlyOptionalKeys" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class ObjectCake<P extends ObjectCakeProperties> extends Cake<({
    -readonly [K in OnlyRequiredKeys<P>]: P[K] extends Cake ? Infer<P[K]> : never;
} & {
    -readonly [K in OnlyOptionalKeys<P>]?: P[K] extends OptionalTag<infer I extends Cake> ? Infer<I> | undefined : never;
} extends infer I ? {
    [K in keyof I]: I[K];
} : never) & object> implements ObjectCakeArgs<P> {
    constructor(args: ObjectCakeArgs<P>);
    // (undocumented)
    dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    dispatchStringify(context: CakeDispatchStringifyContext): string;
    // (undocumented)
    readonly properties: Readonly<P>;
    // (undocumented)
    withName(name: string | null): ObjectCake<P>;
}

// @public (undocumented)
export interface ObjectCakeArgs<P extends ObjectCakeProperties> extends CakeArgs {
    // (undocumented)
    readonly properties: Readonly<P>;
}

// @public (undocumented)
export type ObjectCakeProperties = {
    readonly [key: string | symbol]: Cake | OptionalTag<Cake>;
};

// @public (undocumented)
export class ObjectPropertiesCakeError extends CakeError {
    constructor(cake: ObjectCake<any>, value: object, errors: Record<string | symbol, CakeError>);
    // (undocumented)
    readonly cake: ObjectCake<any>;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly errors: Record<string | symbol, CakeError>;
    // (undocumented)
    readonly value: object;
}

// @public
export const ObjectUtils: {
    readonly entries: typeof entries;
    readonly entriesIncludingSymbols: typeof entriesIncludingSymbols;
    readonly entriesIncludingSymbolsUnsound: typeof entriesIncludingSymbolsUnsound;
    readonly entriesUnsound: typeof entriesUnsound;
    readonly keys: typeof keys;
    readonly keysIncludingSymbols: typeof keysIncludingSymbols;
    readonly keysIncludingSymbolsUnsound: typeof keysIncludingSymbolsUnsound;
    readonly keysUnsound: typeof keysUnsound;
    readonly mapValues: typeof mapValues;
    readonly mapValuesUnsound: typeof mapValuesUnsound;
    readonly merge: typeof merge;
    readonly omit: typeof omit;
    readonly omitLoose: typeof omitLoose;
    readonly pick: typeof pick;
    readonly values: typeof values;
    readonly valuesIncludingSymbols: typeof valuesIncludingSymbols;
    readonly valuesIncludingSymbolsUnsound: typeof valuesIncludingSymbolsUnsound;
    readonly valuesUnsound: typeof valuesUnsound;
};

// Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
//
// @public
export class Ok<T> extends ResultClass<T, never> {
    // @internal
    constructor(value: T);
    // (undocumented)
    errorOr<F>(ifOk: F): F;
    readonly ok = true;
    // (undocumented)
    toString(): string;
    readonly value: T;
    // (undocumented)
    valueOr(_IGNORED: unknown): T;
}

// @public
export function omit<T extends object, K extends (keyof T & (string | symbol))[]>(object: T, ...keys: K): {
    [L in Exclude<keyof T, K[number]>]: T[L];
};

// @public
export function omitLoose<T extends object, K extends (string | symbol)[]>(object: T, ...keys: K): {
    [L in Exclude<keyof T, K[number]>]: T[L];
};

// @public
export function optional<T>(value: T): OptionalTag<T>;

// Warning: (ae-forgotten-export) The symbol "Tag" needs to be exported by the entry point index.d.ts
//
// @public
export class OptionalTag<T> extends Tag<"optional", T> {
    constructor(untagged: T);
}

// @public
export function pick<T extends object, K extends (keyof T & (string | symbol))[]>(object: T, ...keys: K): {
    [L in K[number]]: T[L];
};

// @public
export type Primitive = bigint | boolean | number | string | symbol | null | undefined;

// @public (undocumented)
export function reference<T, C extends Cake<T> = Cake<T>>(get: () => C, name?: string | null): ReferenceCake<C>;

// @public (undocumented)
export class ReferenceCake<C extends Cake> extends Cake<Infer<C>> implements ReferenceCakeArgs<C> {
    constructor(args: ReferenceCakeArgs<C>);
    // (undocumented)
    dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    dispatchStringify(context: CakeDispatchStringifyContext): string;
    // (undocumented)
    readonly get: () => C;
    // (undocumented)
    withName(name: string | null): ReferenceCake<C>;
}

// @public (undocumented)
export interface ReferenceCakeArgs<C extends Cake> extends CakeArgs {
    // (undocumented)
    readonly get: () => C;
}

// @public (undocumented)
export class RequiredPropertyMissingCakeError extends CakeError {
    constructor(cake: Cake);
    // (undocumented)
    readonly cake: Cake;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
}

// @public (undocumented)
export function rest<T>(value: T): RestTag<T>;

// @public (undocumented)
export class RestTag<T> extends Tag<"rest", T> {
    constructor(untagged: T);
}

// @public
export type Result<T, E> = Ok<T> | Err<E>;

// Warning: (ae-forgotten-export) The symbol "ResultUtils" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const Result: ResultUtils;

// @public
export function sameValueZero(a: unknown, b: unknown): boolean;

// @public
export const string: TypeGuardCake<string>;

// @public
export function stringifyPrimitive(value: Primitive): string;

// @public (undocumented)
export type StringTree = string | readonly [string, readonly StringTree[]];

// @public
export const symbol: TypeGuardCake<symbol>;

// Warning: (ae-forgotten-export) The symbol "MapInfer" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MapInferOptional" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TupleCakeArgs" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class TupleCake<S extends readonly Cake[], O extends readonly Cake[], R extends Cake | null, E extends readonly Cake[]> extends Cake<[
...MapInfer<S>,
...MapInferOptional<O>,
...(R extends Cake ? [...Infer<R>[]] : []),
...MapInfer<E>
]> implements TupleCakeArgs<S, O, R, E> {
    constructor(args: TupleCakeArgs<S, O, R, E>);
    // (undocumented)
    dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    dispatchStringify(context: CakeDispatchStringifyContext): string;
    // Warning: (ae-forgotten-export) The symbol "MapOptionalTag" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    elements(): [
    ...S,
    ...MapOptionalTag<O>,
    ...(R extends null ? [] : [RestTag<R>]),
    ...E
    ];
    // (undocumented)
    elements(length: number): (S[number] | OptionalTag<O[number]> | (R extends null ? never : RestTag<R>) | E[number])[] | null;
    // (undocumented)
    readonly endElements: E;
    // (undocumented)
    maxLength(): number | null;
    // (undocumented)
    minLength(): number;
    // (undocumented)
    readonly optionalElements: O;
    // (undocumented)
    readonly restElement: R;
    // (undocumented)
    readonly startElements: S;
    // (undocumented)
    withName(name: string | null): TupleCake<S, O, R, E>;
}

// @public (undocumented)
export class TupleElementsCakeError extends CakeError {
    constructor(cake: TupleCake<readonly Cake[], readonly Cake[], Cake | null, readonly Cake[]>, value: unknown, errors: Record<string, CakeError>);
    // (undocumented)
    readonly cake: TupleCake<readonly Cake[], readonly Cake[], Cake | null, readonly Cake[]>;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly errors: Record<string, CakeError>;
    // (undocumented)
    readonly value: unknown;
}

// @public (undocumented)
export class TupleWrongLengthCakeError extends CakeError {
    constructor(cake: TupleCake<readonly Cake[], readonly Cake[], Cake | null, readonly Cake[]>, value: unknown[]);
    // (undocumented)
    readonly cake: TupleCake<readonly Cake[], readonly Cake[], Cake | null, readonly Cake[]>;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown[];
}

// @public (undocumented)
export function typeGuard<T>(name: string, guard: (value: unknown) => value is T): TypeGuardCake<T>;

// @public (undocumented)
export class TypeGuardCake<T> extends Cake<T> implements TypeGuardCakeArgs<T> {
    constructor(args: TypeGuardCakeArgs<T>);
    // (undocumented)
    dispatchCheck(value: unknown, context: CakeDispatchCheckContext): CakeError | null;
    // (undocumented)
    dispatchStringify(context: CakeDispatchStringifyContext): string;
    // (undocumented)
    readonly guard: (value: unknown) => value is T;
    // (undocumented)
    withName(name: string | null): TypeGuardCake<T>;
}

// @public (undocumented)
export interface TypeGuardCakeArgs<T> extends CakeArgs {
    // (undocumented)
    readonly guard: (value: unknown) => value is T;
}

// @public (undocumented)
export class TypeGuardFailedCakeError extends CakeError {
    constructor(cake: TypeGuardCake<any>, value: unknown);
    // (undocumented)
    readonly cake: TypeGuardCake<any>;
    // (undocumented)
    dispatchFormat(context: CakeErrorDispatchFormatContext): StringTree;
    // (undocumented)
    readonly value: unknown;
}

// @public
export const unknown: TypeGuardCake<unknown>;

// @public
export function values(object: object): unknown[];

// @public
export function valuesIncludingSymbols(object: object): unknown[];

// @public
export function valuesIncludingSymbolsUnsound<T extends object>(object: T): T[keyof T & (string | symbol)][];

// @public
export function valuesUnsound<T extends object>(object: T): T[keyof T & string][];

// (No @packageDocumentation comment for this package)

```
