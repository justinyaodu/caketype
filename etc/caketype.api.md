## API Report File for "caketype"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type Assert<T extends true> = never;

// @public
export type AssertExtends<T extends U, U> = never;

// @public
export interface Class<T = any, A extends unknown[] = any> extends Function {
    // (undocumented)
    new (...args: A): T;
}

// Warning: (ae-forgotten-export) The symbol "DeepMapLike" needs to be exported by the entry point index.d.ts
//
// @public
export function deepDelete<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): boolean;

// Warning: (ae-forgotten-export) The symbol "DeepValue" needs to be exported by the entry point index.d.ts
//
// @public
export function deepDeleteResult<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): Result<DeepValue<M, K>, undefined>;

// @public
export function deepGet<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): DeepValue<M, K> | undefined;

// @public
export function deepGetResult<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): Result<DeepValue<M, K>, undefined>;

// @public
export function deepHas<M extends DeepMapLike<K>, K extends [unknown, ...unknown[]]>(map: M, ...keys: K): boolean;

// Warning: (ae-forgotten-export) The symbol "DeepMap" needs to be exported by the entry point index.d.ts
//
// @public
export function deepSet<M extends DeepMap<K>, K extends [unknown, ...unknown[]]>(map: M, ...keysAndValue: [...K, DeepValue<M, K>]): void;

// @public
export function deleteResult<K, V>(map: MapLike<K, V>, key: K): Result<V, undefined>;

// @public
export function entries(object: object): [string, unknown][];

// @public
export function entriesIncludingSymbols(object: object): [string | symbol, unknown][];

// @public
export function entriesIncludingSymbolsUnsound<T extends object>(object: T): EntryIncludingSymbols<T>[];

// @public
export function entriesUnsound<T extends object>(object: T): Entry<T>[];

// @public
export type Entry<T extends object> = {
    [K in keyof T & string]: [K, T[K]];
}[keyof T & string];

// @public
export type EntryIncludingSymbols<T extends object> = {
    [K in keyof T & (string | symbol)]: [K, T[K]];
}[keyof T & (string | symbol)];

// @public
export type Equivalent<T, U> = [T] extends [U] ? [U] extends [T] ? true : false : false;

// Warning: (ae-forgotten-export) The symbol "ResultClass" needs to be exported by the entry point index.d.ts
// Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
//
// @public
export class Err<E> extends ResultClass<never, E> {
    // @internal
    constructor(error: E);
    readonly error: E;
    // (undocumented)
    errorOr(_IGNORED: unknown): E;
    readonly ok = false;
    // (undocumented)
    toString(): string;
    // (undocumented)
    valueOr<U>(ifErr: U): U;
}

// @public
export type Extends<T, U> = [T] extends [U] ? true : false;

// @public
export function getOrSet<K, V>(map: MapLike<K, V>, key: K, defaultValue: V): V;

// @public
export function getOrSetComputed<K, V>(map: MapLike<K, V>, key: K, keyToDefaultValue: (key: K) => V): V;

// @public
export function getResult<K, V>(map: MapLike<K, V>, key: K): Result<V, undefined>;

// @public
export type If<T extends boolean, U, V> = T extends true ? U : V;

// @public
export function isPrimitive(value: unknown): value is Primitive;

// @public
export function keys(object: object): string[];

// @public
export function keysIncludingSymbols(object: object): (string | symbol)[];

// @public
export function keysIncludingSymbolsUnsound<T extends object>(object: T): (keyof T & (string | symbol))[];

// @public
export function keysUnsound<T extends object>(object: T): (keyof T & string)[];

// Warning: (ae-forgotten-export) The symbol "LookupReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function lookup<K extends PropertyKey, T extends [object, ...object[]]>(key: K, ...objects: T): LookupReturn<K, T>;

// @public
export interface MapLike<K, V> {
    delete(key: K): boolean;
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): MapLike<K, V>;
}

// @public
export const MapUtils: {
    readonly deleteResult: typeof deleteResult;
    readonly deepDelete: typeof deepDelete;
    readonly deepDeleteResult: typeof deepDeleteResult;
    readonly deepGet: typeof deepGet;
    readonly deepGetResult: typeof deepGetResult;
    readonly deepHas: typeof deepHas;
    readonly deepSet: typeof deepSet;
    readonly getOrSet: typeof getOrSet;
    readonly getOrSetComputed: typeof getOrSetComputed;
    readonly getResult: typeof getResult;
};

// @public
export function mapValues<T extends object, R>(object: T, mapper: (value: unknown, key: string | symbol, object: T) => R): {
    [K in keyof T & (string | symbol)]: R;
};

// @public
export function mapValuesUnsound<T extends object, R>(object: T, mapper: <K extends keyof T & (string | symbol)>(value: T[K], key: K, object: T) => R): {
    [K in keyof T & (string | symbol)]: R;
};

// @public
export function merge<T extends [object, ...object[]]>(...objects: T): Merged<T>;

// Warning: (ae-forgotten-export) The symbol "MergeTwo" needs to be exported by the entry point index.d.ts
//
// @public
export type Merged<T extends [object, ...object[]]> = T extends [
infer F extends object,
infer S extends object,
...infer R extends object[]
] ? Merged<[MergeTwo<F, S>, ...R]> : T extends [infer F extends object] ? MergeTwo<F, {}> : never;

// @public
export type Not<T extends boolean> = T extends true ? false : true;

// @public
export const ObjectUtils: {
    readonly entries: typeof entries;
    readonly entriesIncludingSymbols: typeof entriesIncludingSymbols;
    readonly entriesIncludingSymbolsUnsound: typeof entriesIncludingSymbolsUnsound;
    readonly entriesUnsound: typeof entriesUnsound;
    readonly keys: typeof keys;
    readonly keysIncludingSymbols: typeof keysIncludingSymbols;
    readonly keysIncludingSymbolsUnsound: typeof keysIncludingSymbolsUnsound;
    readonly keysUnsound: typeof keysUnsound;
    readonly mapValues: typeof mapValues;
    readonly mapValuesUnsound: typeof mapValuesUnsound;
    readonly merge: typeof merge;
    readonly omit: typeof omit;
    readonly omitLoose: typeof omitLoose;
    readonly pick: typeof pick;
    readonly values: typeof values;
    readonly valuesIncludingSymbols: typeof valuesIncludingSymbols;
    readonly valuesIncludingSymbolsUnsound: typeof valuesIncludingSymbolsUnsound;
    readonly valuesUnsound: typeof valuesUnsound;
};

// Warning: (ae-unresolved-link) The @link reference could not be resolved: The reference is ambiguous because "Result" has more than one declaration; you need to add a TSDoc member reference selector
//
// @public
export class Ok<T> extends ResultClass<T, never> {
    // @internal
    constructor(value: T);
    // (undocumented)
    errorOr<F>(ifOk: F): F;
    readonly ok = true;
    // (undocumented)
    toString(): string;
    readonly value: T;
    // (undocumented)
    valueOr(_IGNORED: unknown): T;
}

// @public
export function omit<T extends object, K extends (keyof T & (string | symbol))[]>(object: T, ...keys: K): {
    [L in Exclude<keyof T, K[number]>]: T[L];
};

// @public
export function omitLoose<T extends object, K extends (string | symbol)[]>(object: T, ...keys: K): {
    [L in Exclude<keyof T, K[number]>]: T[L];
};

// @public
export function pick<T extends object, K extends (keyof T & (string | symbol))[]>(object: T, ...keys: K): {
    [L in K[number]]: T[L];
};

// @public
export type Primitive = bigint | boolean | number | string | symbol | null | undefined;

// @public
export type Result<T, E> = Ok<T> | Err<E>;

// Warning: (ae-forgotten-export) The symbol "ResultUtils" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const Result: ResultUtils;

// @public
export function sameValueZero(a: unknown, b: unknown): boolean;

// @public
export function stringifyPrimitive(value: Primitive): string;

// @public
export function values(object: object): unknown[];

// @public
export function valuesIncludingSymbols(object: object): unknown[];

// @public
export function valuesIncludingSymbolsUnsound<T extends object>(object: T): T[keyof T & (string | symbol)][];

// @public
export function valuesUnsound<T extends object>(object: T): T[keyof T & string][];

// (No @packageDocumentation comment for this package)

```
